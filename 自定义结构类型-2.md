---
title: 自定义结构类型(2)
date: 2021-03-28 11:21:44
tags:
	-	-C语言
	- 	-笔记
categories:
	- C语言
cover: /img/shuyun.png
---

# 结构体

参考视频：https://www.bilibili.com/video/BV1oi4y1g7CF?p=58

**大纲：**

1. 结构体的声明

2. 结构体的自引用

3. 结构体内存对齐

4. 结构体传参

5. 结构体实现位段(位段的填充&可移植性)

   **************

   char short  int long short float double -这些都叫做内置类型，是C语言自己的类型

   对于一些复杂对象，光用内置函数是不够的。

   复杂类型(自定义类型)-结构体、枚举、联合体。



## 1.结构体的声明

1. **结构体的基础知识**：结构体是一些值的集合，这些值称为成员变量。结构体的每个成员可以是不同类型的变量。

   ***

   **结构体的声明**

   ```c
   struct Stu//随便定义名字
   {
       member-list;
   }vairable-list;
   ```

   

例如描述一个学生

```c
#include<stdio.h>
//声明一个结构题类型
//声明一个学生类型，通过学生类型来创建学生变量(对象)
//描述学生；属性-名字-电话-性别
struct Stu
{
    //下面这些叫做成员变量
    char name[20];//名字
    char tele[12];//电话
    int age;//年龄
    char sex[5];//性别
    char id[20];//学号
}s4, s5, s6;//变量列表;//分号不能丢
//全局变量 上面的s4~6也是
struct Stu s3;
int main(void)
{	
    //创建结构体变量
    struct Stu s1;
    struct Stu s1;

	return 0;
}
```

**特殊的声明**

在结构声明的时候，可以不完全的声明。

```c
//匿名结构体类型 没给结构体名字
struct 
{
	int a ;
    char b ;
    float c;   
}x;//没有结构体名字，只有一种创建方式，赶紧用这个匿名结构体类型的变量列表创建一个x，否则以后就创建不了了，因为该结构体没有具体的名字。
struct 
{
	int a ;
    char b ;
    float c;   
}a[20],*p;
//上面两个结构在声明的时候省略掉了结构体标签(tag)
//p = &x;是不合法的，编译器会把上面的两个声明当成完全不同的两个类型。所以是非法的。
```

## 2.结构的自引用

***

数据结构：数据在内存中的存储结构  

***

**错误自引用**

```c
struct Node
{
    int data; // 4
    struct Nod n; //4
    //n里面包含n,程序报错。//类似于递归的思路
};
int main(void)
{	
    sizeof(struct Node);
    return 0;
}
```

**正确方式：结构体能够找到同类型的其他的变量，用指针串连起来。**

```c
//存放数据的地方叫数据域 存放地址的地方叫指针域
struct Node
{
    int data; // 4
    struct Node* next; //4
};
int main(void)
{	
   
    return 0;
}
```

**typedef重命名**

```c
typedef struct Node  //自引用的时候不建议省略名称
{
	int data;
    
}Node;//结尾的这个Node是类型名，不是变量名
```

## 3.结构体变量的定义和初始化

**结构体变量的初始化**

```c
//初始化结构体中的结构体
struct T
{
    double weight;
    short age;
}
struct S
{
    char c;
    struct T sy;
    int a ;
    double d;
    char arr[20];
}
int main(void)
 {
    //结构体初始化的时候用大括号
    struct S s = {'c'，{2.21,2},100,3.14，'hello sb'};
    //结构体成员的访问
    printf("%c %d %lf %s\n",s.c,s.a,s.d,s.arr);
    printf("%lf",s.st.weight);
 	return 0;
 }
```

## 4.结构体内存对齐

```c
struct S1
{	
    char C1;
    int a;
    char c2;
};
struct S1
{	
    char C1;
    char c2;
    int a;
};
int main(void)
{	
    struct S1 s1 = {0};//一个0 将里面所有的内容都初始化0
    struct S2 s2= {0};
    printf("%d",sizeof(s2));// 12
    printf("%d",sizeof(s2));// 8
	return 0;
}
```

**结构体的对齐规则：**

1.第一个成员在与结构体变量偏移为0的地址处。

2.其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。

对齐数=编译器默认的一个对齐数与该成员大小的较小值。

VS中默认的值是8            gcc编译器没有默认对齐数。

3.结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。

4.如果嵌套结构体的情况，嵌套的结构对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

**为什么存在内存对齐？**

1.平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的，某些硬件平台只能在某些地址处取某些特定类型的数据。否则抛出硬件异常。

2.性能原因：数据结构(尤其是栈)应该尽可能地在自然边界对齐。原因在于，为了访问未对齐的内存，处理器需要做两次内存访问；而对齐的内存访问仅需要一次访问。

**总的来说：**

​	结构体的内存对齐是拿空间来换取时间的做法。提升一下效率。

**如何设计结构体**

既要满足对齐，又要节省空间。

​                                        **让占用空间小的成员尽量集中在一起**。

例如：

```c
struct S1
{
	char c1;
	int i;
	char c2;
};
struct S2
{
	char c1;
	char c2;
	int i;
};
S1和S2的结构体成员一模一样，但是S1和S2所占空间的大小有了一些区别。

```

**修改默认对齐数**

**#pragma pack()**

```c
#include<stdio.h>
#pragma pack(4)//设置默认对齐数为4
//默认对齐数设置为1，其实就没有对齐了，就该是什么就往里面放什么了。
struct S
{
	char a;
	double d;	

};
#pragma pack()//取消设置的默认对齐数
int main(void)
{	
	struct S s;
	printf("%d\n",sizeof(s));
	return 0;
}
```

**结论：**

结构在对齐方式不合适的时候，我们可以自己更改默认对齐数。

**offsetof()——结构体成员相对于结构体起始位置的偏移量**

头文件——#include<stddef.h>

(结构体名字,结构体成员)

```c
struct S
{
    char c;
    int i;
    double d;
};
int main(void)
{
    printf("%d",offsetof(struct S,c));
    return 0;
}
```

## 5.结构体传参

类似于：函数内部想改变函数外部的某个值的话，就要传地址进去。

（->是C语言和C++语言的一个运算符，叫做指向结构体成员运算符，用处是使用一个指向结构体或对象的指针访问其内成员。）

```c
#include<stdio.h>
struct S
{
	int a;
	char c;
	double d;
};
void Init(struct S* ps)
{
	ps->a = 100;
	ps->c = 'w';
	ps->d = 3.14;
}
//传值
void Print(struct S tmp)
{
	printf("%d %c %lf\n",tmp.a,tmp.c,tmp.d);	
}
//传值
//如果害怕就打印一个值而传值过来可能会导致值的改变，就加一个const
//综合考虑建议结构体传参传地址
void Print(const struct S* ps)
{
    printf("%d %c %lf\n",ps->a,ps->c,ps->d);
}
int main(void)
{
	struct S s = {};
	Init(&s);
    Print1(s);
    Print2(&s);
	return 0;
}
```

函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。

如果传递一个结构体对象的时候，结构体过大，参数压栈的系统开销比较大，所以会导致性能的下降。