# 1.动态内存管理

## 1.为什么存在动态内存管理

当前我们知道的**内存的使用方式**主要是两种。

**1.创建一个变量**

int a = 10;//局部变量  - 在栈区中开辟空间

int g_a = 10;//全局变量 - 静态区

****

在内存中，分为三个区域

**栈区**-局部变量、函数的形参、

**堆区**-动态内存分配-malloc-free-calloc-realloc

**静态区**-全局变量、静态变量、statint int a = 10;

***

**2.创建一个数组**

int arr[10] =  { 10 };（局部范围-栈区，全局范围-静态区）

在空间上开辟10个字节的连续空间。

```c
struct S
{
  char name[20];
  int age;
};
int main(void)
{	
    struct S arr[50];//50个struct S类型的数据
    //如果只有30个学生，就会有空间上的浪费
    //如果有60个学生，空间又会不够
    //数组的元素个数，是给定的一个常量
    return 0;
}
```

****

C语言是可以创建变长数组的 -C99中增加了（很多个编译器可能都还没有支持）

不够普遍。

***

因为上面的两种开辟内存空间的方式比较局限，不能满足我们想用多少就开辟多少空间的需求，所以引出动态内存管理。

**提高内存的使用率。**

## 2.相关函数

### 1.malloc和free

**头文件：#include<stdlib.h>**

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<errno.h>
int main(void)
{
    //向内存申请10整型的空间
    int* p = (int*)malloc(10 * sizeof(int));//p里面放的就是那块地址
    //失败时返回空指针NULL
    if (p == NULL)
    {
        //打印错误原因的一个方式
        printf("%s\n", strerror(errno));
    }
    else
    {
        //正常使用空间
        int i = 0;
        for (i = 0; i < 10; i++)
        {
            *(p + i) = i;
        }
        for(i = 0; i < 10 ; i++)
        { 
            printf("%d ", *(p + i));
        }
    }
    //当动态申请的空间不再使用的时候
    //就应该还给操作系统
    return 0;
}
```

**malloc**

C语言提供了一个动态内存开辟的函数：

​	void* malloc (size_t size);

这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。

- 如果开辟成功，则返回一个指向开辟好空间的指针。
- 如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。
- 返回值的类型是*void，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。
- 如果size为0，malloc的行为是标准未定义的，取决于编译器。

****

**free**

C语言提供了另外一个函数free,专门是用来做动态内存释放和回收的。

free(空间);例如：上面开辟的那个，free(p);

//就算不free，刚才开辟的空间死掉的话，也会自动还给操作系统。

free之后，指向的将内存空间被释放了还给操作系统，但是p依然有能力找到这快空间，

p = NULL，主动将p赋值给空指针，彻底断开了联系，很好的避免了它犯错误。



free函数用来释放动态开辟的内存

- 如果参数ptr指向的空间不是动态开辟的，那free函数的行为是未定义的。

- 如果参数prt是NULL指针，咋函数什么事都不做。


### 2.calloc

也是一个内存开辟函数，开辟一个空间并且把元素初始化为0.

原型如下：

void* 

```c
int main(void)
{
    int*p= (int*)calloc(10,sizeof(int));  
    if( p == NULL)
    {
        printf("%s\n",strerror(errno));
    }
    else
    {
        int i = 0;
        for(i = 0;i < 10;i ++)
        {
            printf("%d",(*p+1));
        }
    }
    //释放空间
    //free函数是用来释放动态开辟的内存空间的
    free(p);
    p = NULL;
    return 0;
}
```

calloc和malloc一个初始化效率低一点，一个不初始化，效率高一点。

- 函数的功能是为num个大小为size的元素开辟一块空间，并且把空间的每个字节初始化为0。
- 与函数malloc的区别只在于calloc会在返回地址之前把申请的空间的每个字节初始化为全0。

### 3.realloc

**调整动态开辟内存的大小**

```c
int main(void)
{	
    int *p = (int*)malloc(20);
    if(p == NULL)
    {
        printf("%s\n",strerror(errno));
    }
    else
    {
        int i = 0;
        for(i = 0;i < 5; i ++)
        {
            *(p+i) = i;
        }
	}
    //只是在使用malloc开辟的20个字节空间
    //假设这里，20个字节不能满足我们的使用要求
    //希望我们能够有40个字节的空间
    //这里就可以使用realloc来调整动态开辟的内存
    int realloc(p,40);
    int *p2 = realloc(p,40);
    int i = 0;
    for(i = 0;i < 10; i++)
    {
        printf("%d",*(p2+i));
    }
    return 0;
}
```



- realloc函数的出现让动态内存管理更加灵活。
- 有时我们发现过去申请的内存空间太小了，有时候又会觉得申请的空间过大了，那为了合理的使用内存，我们一定会对内存的大小做灵活的调整。那realloc函数就可以做到对动态开辟内存大小的调整。函数原型如下：

void* realloc (void* ptr,size_t size);

- ptr是要调整的内存地址
- size是调整之后的大小
- 返回值为调整之后的内存起始位置
- 这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间
- realloc在调整内存空间存在两种情况

**注意事项：**

1. 如果p指向的空间之后有足够的内存空间可以追加，则直接追加，后返回p指向空间的地址。
2. 如果p指向的空间之后没有足够的内存空间可以追加，则realloc函数会重新找一块新的内存区域，开辟一块满足需求的空间并且把原来内存中的数据拷贝回来，释放旧的内存空间。最后返回新开辟的内存空间地址。
3. 得用一个新的变量来接收realloc的返回值。
4. 最后都要free

